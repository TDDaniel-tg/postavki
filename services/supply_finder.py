import asyncio
from typing import Optional, List
from datetime import datetime, timedelta
from loguru import logger

from database import DatabaseManager
from wb_api import WildberriesAPI, SupplySlot
from services.booking import BookingService
from services.notification import NotificationService


class SupplyFinderService:
    """Service for continuous supply slot finding and booking"""
    
    def __init__(self, db: DatabaseManager, booking_service: BookingService, notification_service: NotificationService):
        self.db = db
        self.booking_service = booking_service
        self.notification_service = notification_service
        self.active_searches = {}  # user_id -> search task
        self.search_interval = 30  # –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–∏—Å–∫–∞ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
        
    async def start_supply_search(self, user_id: int, account_id: int, supply_number: str) -> bool:
        """Start continuous search for supply slots"""
        try:
            # Stop existing search if any
            await self.stop_supply_search(user_id)
            
            # Get user and account
            user = await self.db.get_user_with_accounts(user_id)
            if not user:
                logger.error(f"User {user_id} not found")
                return False
            
            account = next((acc for acc in user.wb_accounts if acc.id == account_id), None)
            if not account or not account.is_active:
                logger.error(f"Account {account_id} not found or inactive")
                return False
            
            # Create search task
            task = asyncio.create_task(
                self._continuous_search(user_id, account_id, supply_number)
            )
            self.active_searches[user_id] = {
                'task': task,
                'supply_number': supply_number,
                'account_id': account_id,
                'started_at': datetime.now()
            }
            
            logger.info(f"Started continuous search for supply {supply_number}, user {user_id}")
            
            # Notify user about search start
            await self.notification_service.send_message(
                user_id=user_id,
                message=(
                    f"üîç **–ü–æ–∏—Å–∫ —Å–ª–æ—Ç–∞ –∑–∞–ø—É—â–µ–Ω**\n\n"
                    f"üì¶ **–ü–æ—Å—Ç–∞–≤–∫–∞**: {supply_number}\n"
                    f"üíº **–ê–∫–∫–∞—É–Ω—Ç**: {account.name}\n\n"
                    f"‚è∞ –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–ª–æ—Ç–æ–≤ –∫–∞–∂–¥—ã–µ {self.search_interval} —Å–µ–∫—É–Ω–¥\n"
                    f"üéØ –ö–∞–∫ —Ç–æ–ª—å–∫–æ –Ω–∞–π–¥–µ—Ç—Å—è –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Å–ª–æ—Ç - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–±—Ä–æ–Ω–∏—Ä—É—é!\n\n"
                    f"‚ùå –î–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–æ–∏—Å–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∏—Å–∫'"
                ),
                parse_mode="Markdown"
            )
            
            return True
            
        except Exception as e:
            logger.error(f"Error starting supply search: {e}")
            return False
    
    async def stop_supply_search(self, user_id: int) -> bool:
        """Stop continuous search for user"""
        try:
            if user_id in self.active_searches:
                search_info = self.active_searches[user_id]
                search_info['task'].cancel()
                
                try:
                    await search_info['task']
                except asyncio.CancelledError:
                    pass
                
                del self.active_searches[user_id]
                
                # Calculate search duration
                duration = datetime.now() - search_info['started_at']
                hours = int(duration.total_seconds() // 3600)
                minutes = int((duration.total_seconds() % 3600) // 60)
                
                # Notify user about search stop
                await self.notification_service.send_message(
                    user_id=user_id,
                    message=(
                        f"‚èπÔ∏è **–ü–æ–∏—Å–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω**\n\n"
                        f"üì¶ **–ü–æ—Å—Ç–∞–≤–∫–∞**: {search_info['supply_number']}\n"
                        f"‚è±Ô∏è **–í—Ä–µ–º—è –ø–æ–∏—Å–∫–∞**: {hours}—á {minutes}–º\n\n"
                        f"üí° –ú–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ –º–µ–Ω—é"
                    ),
                    parse_mode="Markdown"
                )
                
                logger.info(f"Stopped supply search for user {user_id}")
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error stopping supply search: {e}")
            return False
    
    async def _continuous_search(self, user_id: int, account_id: int, supply_number: str):
        """Continuous search loop"""
        search_attempts = 0
        
        try:
            while True:
                search_attempts += 1
                logger.debug(f"Search attempt #{search_attempts} for supply {supply_number}")
                
                try:
                    # Try to find and book slot
                    success = await self.booking_service.auto_book_supply(
                        user_id=user_id,
                        account_id=account_id,
                        supply_number=supply_number
                    )
                    
                    if success:
                        # Booking successful - stop search
                        logger.info(f"Successfully booked supply {supply_number} after {search_attempts} attempts")
                        
                        # Remove from active searches
                        if user_id in self.active_searches:
                            del self.active_searches[user_id]
                        
                        # Notify about successful booking
                        await self.notification_service.send_message(
                            user_id=user_id,
                            message=(
                                f"‚úÖ **–ü–æ—Å—Ç–∞–≤–∫–∞ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∞!**\n\n"
                                f"üì¶ **–ù–æ–º–µ—Ä –ø–æ—Å—Ç–∞–≤–∫–∏**: {supply_number}\n"
                                f"üî¢ **–ü–æ–ø—ã—Ç–æ–∫ –ø–æ–∏—Å–∫–∞**: {search_attempts}\n\n"
                                f"üéâ –ü–æ–∏—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ!"
                            ),
                            parse_mode="Markdown"
                        )
                        
                        break
                    
                    else:
                        # No suitable slot found, continue searching
                        logger.debug(f"No suitable slot found for supply {supply_number}, attempt #{search_attempts}")
                        
                        # Send periodic status update (every 10 attempts)
                        if search_attempts % 10 == 0:
                            await self.notification_service.send_message(
                                user_id=user_id,
                                message=(
                                    f"üîç **–ü–æ–∏—Å–∫ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è...**\n\n"
                                    f"üì¶ **–ü–æ—Å—Ç–∞–≤–∫–∞**: {supply_number}\n"
                                    f"üî¢ **–ü–æ–ø—ã—Ç–æ–∫**: {search_attempts}\n"
                                    f"‚è∞ **–ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞**: {datetime.now().strftime('%H:%M:%S')}\n\n"
                                    f"üí° –ü—Ä–æ–¥–æ–ª–∂–∞—é –∏—Å–∫–∞—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Å–ª–æ—Ç—ã..."
                                ),
                                parse_mode="Markdown"
                            )
                    
                except Exception as e:
                    logger.error(f"Error in search attempt #{search_attempts}: {e}")
                    
                    # Send error notification (every 20 failed attempts)
                    if search_attempts % 20 == 0:
                        await self.notification_service.send_message(
                            user_id=user_id,
                            message=(
                                f"‚ö†Ô∏è **–ü—Ä–æ–±–ª–µ–º—ã —Å –ø–æ–∏—Å–∫–æ–º**\n\n"
                                f"üì¶ **–ü–æ—Å—Ç–∞–≤–∫–∞**: {supply_number}\n"
                                f"‚ùå **–û—à–∏–±–æ–∫**: {search_attempts}\n\n"
                                f"üîÑ –ü—Ä–æ–¥–æ–ª–∂–∞—é –ø–æ–ø—ã—Ç–∫–∏ –ø–æ–∏—Å–∫–∞...\n"
                                f"üìû –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –Ω–µ —Ä–µ—à–∞–µ—Ç—Å—è - –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É"
                            ),
                            parse_mode="Markdown"
                        )
                
                # Wait before next attempt
                await asyncio.sleep(self.search_interval)
                
        except asyncio.CancelledError:
            logger.info(f"Search cancelled for supply {supply_number}")
            raise
        except Exception as e:
            logger.error(f"Fatal error in continuous search: {e}")
            
            # Notify about fatal error
            await self.notification_service.send_message(
                user_id=user_id,
                message=(
                    f"‚ùå **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞**\n\n"
                    f"üì¶ **–ü–æ—Å—Ç–∞–≤–∫–∞**: {supply_number}\n"
                    f"üî¢ **–ü–æ–ø—ã—Ç–æ–∫ –¥–æ –æ—à–∏–±–∫–∏**: {search_attempts}\n\n"
                    f"üí≠ **–û—à–∏–±–∫–∞**: {str(e)[:100]}...\n\n"
                    f"üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ"
                ),
                parse_mode="Markdown"
            )
            
            # Remove from active searches
            if user_id in self.active_searches:
                del self.active_searches[user_id]
    
    def get_active_searches(self) -> List[dict]:
        """Get list of active searches"""
        result = []
        for user_id, search_info in self.active_searches.items():
            result.append({
                'user_id': user_id,
                'supply_number': search_info['supply_number'],
                'account_id': search_info['account_id'],
                'started_at': search_info['started_at'],
                'duration': datetime.now() - search_info['started_at']
            })
        return result
    
    def is_user_searching(self, user_id: int) -> bool:
        """Check if user has active search"""
        return user_id in self.active_searches
    
    def get_user_search_info(self, user_id: int) -> Optional[dict]:
        """Get user's current search info"""
        return self.active_searches.get(user_id)
    
    async def stop_all_searches(self):
        """Stop all active searches (for shutdown)"""
        logger.info(f"Stopping {len(self.active_searches)} active searches...")
        
        for user_id in list(self.active_searches.keys()):
            await self.stop_supply_search(user_id)
        
        logger.info("All searches stopped") 